#!/usr/bin/env python3

import argparse

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as tick
from matplotlib import gridspec

aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8.0, 9.25, 10.0
offblack = '#262626'

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'serif',
    'font.serif': ['CMU Serif'],
    'font.size': texsmall,
    'legend.fontsize': texsmall,
    'axes.labelsize': texsmall,
    'axes.titlesize': texsmall,
    'xtick.labelsize': textiny,
    'ytick.labelsize': textiny,
    'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'lines.linewidth': .9,
    'lines.markersize': 3,
    'lines.markeredgewidth': .1,
    'patch.linewidth': .9,
    'axes.linewidth': .5,
    'xtick.major.width': .5,
    'ytick.major.width': .5,
    'xtick.minor.width': .5,
    'ytick.minor.width': .5,
    'xtick.major.size': 2,
    'ytick.major.size': 2,
    'xtick.minor.size': 1.3,
    'ytick.minor.size': 1.3,
    'xtick.major.pad': 1.8,
    'ytick.major.pad': 1.8,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'image.interpolation': 'none',
    'pdf.fonttype': 42
})


plot_functions = {}


def plot(f):
    def wrapper(*args, **kwargs):
        print(f.__name__)
        f(*args, **kwargs)
        plt.savefig('{}.pdf'.format(f.__name__))
        plt.close()

    plot_functions[f.__name__] = wrapper

    return wrapper


def finish(despine=True, remove_ticks=False, pad=0.1, h_pad=None, w_pad=None):
    fig = plt.gcf()

    for ax in fig.axes:
        if despine:
            for spine in 'top', 'right':
                ax.spines[spine].set_visible(False)

        if remove_ticks:
            for ax_name in 'xaxis', 'yaxis':
                getattr(ax, ax_name).set_ticks_position('none')
        else:
            ax.xaxis.set_ticks_position('bottom')
            ax.yaxis.set_ticks_position('left')

    fig.tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad)


def set_loc(ax, xy=None, nbins=5, steps=[1, 2, 3, 4, 10],
            prune=None, minor=0):
    if xy == 'x':
        axes = ax.xaxis,
    elif xy == 'y':
        axes = ax.yaxis,
    else:
        axes = ax.xaxis, ax.yaxis

    for axis in axes:
        axis.set_major_locator(
            tick.MaxNLocator(nbins=nbins, steps=steps, prune=prune)
        )
        if minor:
            axis.set_minor_locator(tick.AutoMinorLocator(minor))


def gen_mean(x, y, p):
    if abs(p) < 1e-9:
        return np.sqrt(x * y)
    else:
        return (((x +1e-12)**p + (y + 1e-12)**p)/2)**(1/p)


def kln(x, y):
    Qs2_min = np.minimum(x, y)
    Qs2_max = np.maximum(x, y)
    arg = Qs2_max/(Qs2_min + 1e-12)
    return Qs2_min*(2 + np.log(arg + 1e-12))/2


def ekrt_gen():
    K, beta = 0.5, 0.8
    a = (-0.0044020 + 0.0220154*K - 0.0005974*beta
         + 0.0125320*K*beta - 0.0032844*beta**2 - 0.0033841*K**2)
    b = (0.8537670 - 0.0580163*K + 0.0957157*beta
         - 0.0016413*K*beta - 0.1788390*beta**2 + 0.0220187*K**2)
    C = (3.9027590 - 0.6277216*K + 1.0703962*beta
         + 0.0692793*K*beta - 1.9808449*beta**2 + 0.1106879*K**2)
    n = (0.1312476 - 0.0157637*K - 0.0362980*beta
         - 0.0022506*K*beta + 0.0615129*beta**2 + 0.0052116*K**2)

    def inner(x, y):
        p_sat = C*(a + x*y)**n - b*C*a**n
        e_0 = (K/np.pi)*p_sat**3
        s_0 = e_0**(3/4)

        return s_0

    return inner

ekrt = ekrt_gen()


@plot
def cgc_compare():
    fig, axes = plt.subplots(
        ncols=3, figsize=(textwidth, 0.55*columnwidth), sharey=True
    )

    saturation = [kln, ekrt, lambda x, y: (x + y)/2]
    pvals = [-0.65, 0, 1]
    labels = ['KLN model', 'EKRT model', 'WN model']
    TB = [1, 3, 6]

    for ax, p, func, label in zip(axes, pvals, saturation, labels):
        X = np.linspace(0, 5, 1000)

        [ax.plot(X, gen_mean(X, Y, p), lw=0.8,
                 color=plt.cm.Blues(0.6),
                 label='Gen. Mean; $p={}$'.format(p) if Y == 1 else '')
         for Y in TB]

        [ax.plot(X, func(X, Y), lw=0.8, dashes=(4, 4),
                 color='0.25', label=label if Y == 1 else '')
         for Y in TB]

        radians = np.array([np.arctan2(
            gen_mean(4.5, Y, p) - gen_mean(4.4, Y, p), 0.1) for Y in TB])
        angles = 180*radians/(2*np.pi)
        offsets = [2.62, 3.65, 4.95]
        labels = ['${:d}$', '${:d}$', '$T_B={:d}$']

        if ax == axes[2]:
            [ax.text(5, offset, label.format(int(Y)) + ' fm$^{-2}$',
                     ha='right', va='bottom', rotation=angle)
             for Y, angle, offset, label in zip(TB, angles, offsets, labels)]

        ax.set_xlim(0, 5)
        ax.set_xticks([0, 1, 2, 3, 4])
        ax.set_xlabel(r'$T_A$ [fm$^{-2}$]')
        ax.set_ylim(0, 6.9)
        ax.set_yticks([0, 2, 4, 6])
    
        handles, labels = ax.get_legend_handles_labels()
        ax.legend(handles, labels, bbox_to_anchor=(0, 1.05),
                  loc=2, handlelength=1.5)
    
    axes[0].set_ylabel(r'Entropy density [fm$^{-2}$]')

    finish()


@plot
def thickness():
    fig, axes = plt.subplots(figsize=(columnwidth, aspect*columnwidth))

    X = np.linspace(-9, 9, 361)
    TA = np.loadtxt('data/Pb-Pb/TA.dat')[:,180]
    TB = np.loadtxt('data/Pb-Pb/TB.dat')[:,180]
    Tmin = np.minimum(TA, TB)
    Tmax = np.maximum(TA, TB)
    
    plt.fill_between(X, Tmin, Tmax, lw=0, color='0.6', alpha=0.4,
                    label=r'$T_\mathrm{min} < T < T_\mathrm{max}$')
    
    pvals = [-1, 0, +1]
    colors = [plt.cm.Blues(0.6), plt.cm.Greens(0.65), plt.cm.Purples(0.6)]

    dashes = [(4,0.6,1,0.6,1,0.6), (2,0.6), (4,0.6,1,0.6)]
 
    [plt.plot(X, gen_mean(TA, TB, p), color=color, dashes=dash, 
              label='$p={:+1.0f}$'.format(float(p)))
     for index, [p, color, dash] in enumerate(zip(pvals, colors, dashes))
    ]


    plt.xlim(-8.5, 8.5)
    plt.xticks([-8, -6, -4, -2, 0, 2, 4, 6, 8])
    plt.xlabel(r'$x$ [fm]')
    plt.ylim(0, 5)
    plt.yticks([0, 2, 4])
    plt.ylabel(r'Thickness [fm$^{-2}$]')

    ax = plt.gca()
    handles, labels = ax.get_legend_handles_labels()
    legend = ax.legend(handles[::-1], labels[::-1], labelspacing=0.4,
                       handletextpad=0.4, markerfirst=False, bbox_to_anchor=(1.03, 1.05))
    legend.legendHandles[0].set_color(offblack)
    plt.annotate('Pb+Pb 2.76 TeV', xy=(0.02, 0.985), va='top', color=offblack, xycoords='axes fraction')

    finish()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('plots', nargs='*')
    args = parser.parse_args()

    if args.plots:
        for i in args.plots:
            if i.endswith('.pdf'):
                i = i[:-4]
            if i in plot_functions:
                plot_functions[i]()
            else:
                print('unknown plot:', i)
    else:
        for f in plot_functions.values():
            f()


if __name__ == "__main__":
    main()
