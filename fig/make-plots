#!/usr/bin/env python3

import argparse

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as tick

aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8.0, 9.25, 10.0
offblack = '#262626'

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'serif',
    'font.serif': ['CMU Serif'],
    'font.size': texsmall,
    'legend.fontsize': texsmall,
    'axes.labelsize': texsmall,
    'axes.titlesize': texsmall,
    'xtick.labelsize': textiny,
    'ytick.labelsize': textiny,
    'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'lines.linewidth': .9,
    'lines.markersize': 3,
    'lines.markeredgewidth': .1,
    'patch.linewidth': .9,
    'axes.linewidth': .5,
    'xtick.major.width': .5,
    'ytick.major.width': .5,
    'xtick.minor.width': .5,
    'ytick.minor.width': .5,
    'xtick.major.size': 2,
    'ytick.major.size': 2,
    'xtick.minor.size': 1.3,
    'ytick.minor.size': 1.3,
    'xtick.major.pad': 1.8,
    'ytick.major.pad': 1.8,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'image.interpolation': 'none',
    'pdf.fonttype': 42
})


plot_functions = {}


def plot(f):
    def wrapper(*args, **kwargs):
        print(f.__name__)
        f(*args, **kwargs)
        plt.savefig('{}.pdf'.format(f.__name__))
        plt.close()

    plot_functions[f.__name__] = wrapper

    return wrapper


def finish(despine=True, remove_ticks=False, pad=0.1, h_pad=None, w_pad=None):
    fig = plt.gcf()

    for ax in fig.axes:
        if despine:
            for spine in 'top', 'right':
                ax.spines[spine].set_visible(False)

        if remove_ticks:
            for ax_name in 'xaxis', 'yaxis':
                getattr(ax, ax_name).set_ticks_position('none')
        else:
            ax.xaxis.set_ticks_position('bottom')
            ax.yaxis.set_ticks_position('left')

    fig.tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad)


def set_loc(ax, xy=None, nbins=5, steps=[1, 2, 3, 4, 10],
            prune=None, minor=0):
    if xy == 'x':
        axes = ax.xaxis,
    elif xy == 'y':
        axes = ax.yaxis,
    else:
        axes = ax.xaxis, ax.yaxis

    for axis in axes:
        axis.set_major_locator(
            tick.MaxNLocator(nbins=nbins, steps=steps, prune=prune)
        )
        if minor:
            axis.set_minor_locator(tick.AutoMinorLocator(minor))


def gen_mean(x, y, p):
    if abs(p) < 1e-9:
        return np.sqrt(x * y)
    else:
        return (((x + 1e-12)**p + (y + 1e-12)**p)/2)**(1/p)


def kln(x, y):
    Qs2_min = np.minimum(x, y)
    Qs2_max = np.maximum(x, y)
    arg = Qs2_max/(Qs2_min + 1e-12)
    return Qs2_min*(2 + np.log(arg + 1e-12))/2


def ekrt_gen():
    K, beta = 0.5, 0.8
    a = (-0.0044020 + 0.0220154*K - 0.0005974*beta
         + 0.0125320*K*beta - 0.0032844*beta**2 - 0.0033841*K**2)
    b = (0.8537670 - 0.0580163*K + 0.0957157*beta
         - 0.0016413*K*beta - 0.1788390*beta**2 + 0.0220187*K**2)
    C = (3.9027590 - 0.6277216*K + 1.0703962*beta
         + 0.0692793*K*beta - 1.9808449*beta**2 + 0.1106879*K**2)
    n = (0.1312476 - 0.0157637*K - 0.0362980*beta
         - 0.0022506*K*beta + 0.0615129*beta**2 + 0.0052116*K**2)

    def inner(x, y):
        p_sat = C*(a + x*y)**n - b*C*a**n
        e_0 = (K/np.pi)*p_sat**3
        s_0 = e_0**(3/4)

        return s_0

    return inner

ekrt = ekrt_gen()


@plot
def cgc_compare():
    fig, axes = plt.subplots(
        ncols=3, figsize=(textwidth, 0.55*columnwidth), sharey=True
    )

    saturation = [kln, ekrt, lambda x, y: (x + y)/2]
    pvals = [-0.65, 0, 1]
    labels = ['KLN model', 'EKRT model', 'WN model']
    TB = [1, 3, 6]

    for ax, p, func, label in zip(axes, pvals, saturation, labels):
        X = np.linspace(0, 5, 1000)

        [ax.plot(X, gen_mean(X, Y, p), lw=0.8,
                 color=plt.cm.Blues(0.6),
                 label='Gen. Mean; $p={}$'.format(p) if Y == 1 else '')
         for Y in TB]

        [ax.plot(X, func(X, Y), lw=0.8, dashes=(4, 4),
                 color='0.25', label=label if Y == 1 else '')
         for Y in TB]

        radians = np.array([np.arctan2(
            gen_mean(4.5, Y, p) - gen_mean(4.4, Y, p), 0.1) for Y in TB])
        angles = 180*radians/(2*np.pi)
        offsets = [2.62, 3.65, 4.95]
        labels = ['${:d}$', '${:d}$', '$T_B={:d}$']

        if ax == axes[2]:
            [ax.text(5, offset, label.format(int(Y)) + ' fm$^{-2}$',
                     ha='right', va='bottom', rotation=angle)
             for Y, angle, offset, label in zip(TB, angles, offsets, labels)]

        ax.set_xlim(0, 5)
        ax.set_xticks([0, 1, 2, 3, 4])
        ax.set_xlabel(r'$T_A$ [fm$^{-2}$]')
        ax.set_ylim(0, 6.9)
        ax.set_yticks([0, 2, 4, 6])

        handles, labels = ax.get_legend_handles_labels()
        ax.legend(handles, labels, bbox_to_anchor=(0, 1.05),
                  loc=2, handlelength=1.5)

    axes[0].set_ylabel(r'Entropy density [fm$^{-2}$]')

    finish()


@plot
def thickness():
    plt.figure(figsize=(columnwidth, aspect*columnwidth))

    X = np.linspace(-9, 9, 361)
    TA = np.loadtxt('data/PbPb_TA.dat')[:, 180]
    TB = np.loadtxt('data/PbPb_TB.dat')[:, 180]
    Tmin = np.minimum(TA, TB)
    Tmax = np.maximum(TA, TB)

    blue = plt.cm.Blues(0.6)
    dark_blue = plt.cm.Blues(0.7)

    plt.fill_between(X, Tmin, Tmax, lw=0, color='0.6', alpha=0.4, zorder=0,
                     label=r'$T_\mathrm{min} < T < T_\mathrm{max}$')
    plt.fill_between(X, gen_mean(TA, TB, -1), gen_mean(TA, TB, 1),
                     color=blue, lw=0, alpha=0.4, label=r'$-1<p<1$')
    plt.plot(X, gen_mean(TA, TB, 0), color=dark_blue, label='$p=0$')

    plt.xlim(-8.5, 8.5)
    plt.xticks(np.linspace(-8,8,9))
    plt.xlabel(r'$x$ [fm]')
    plt.ylim(0, 5)
    plt.yticks([0, 2, 4])
    plt.ylabel(r'Thickness [fm$^{-2}$]')

    handles, labels = plt.gca().get_legend_handles_labels()
    handles = handles[1], handles[2], handles[0]
    labels = labels[1], labels[2], labels[0]
    plt.legend(handles, labels, labelspacing=0.4,
               handletextpad=0.4, markerfirst=False,
               bbox_to_anchor=(1.03, 1.05))
    plt.annotate('Pb+Pb 2.76 TeV', xy=(0.02, 0.985), va='top', color=offblack,
                 xycoords='axes fraction')

    finish()


def split_cent_bins(array, bin_edges):
    """
    Split an array into chunks for each centrality bin. The
    array must already be sorted by centrality along its first axis.

    """
    for a, b in zip(bin_edges[:-1], bin_edges[1:]):
        i, j = (int(array.shape[0]*c/100) for c in (a, b))
        yield array[i:j]


@plot
def nch_per_npart():
    plt.figure(figsize=(columnwidth, aspect*columnwidth))

    clow, chigh, alice_nch, alice_error = \
        np.loadtxt('data/ALICE_PbPb_5.02.dat', usecols=(0, 1, 2, 3)).T
    bin_edges = np.append(clow, chigh[-1:])

    trento_data = np.loadtxt('data/PbPb.dat', usecols=(2, 3))
    npart, nch = trento_data[trento_data[:, 1].argsort()[::-1]].T
    trento_npart = np.array(
        [bin.mean() for bin in split_cent_bins(npart, bin_edges)])
    trento_nch = np.array(
        [bin.mean() for bin in split_cent_bins(nch, bin_edges)])
    norm = alice_nch[5]/trento_nch[5]

    plt.plot(trento_npart, norm*trento_nch/(trento_npart/2),
             lw=1, zorder=1, color=plt.cm.Blues(0.6), label='Pb+Pb')
    plt.errorbar(trento_npart, alice_nch/(trento_npart/2),
                 yerr=alice_error/(trento_npart/2), fmt='o', capsize=0,
                 color=offblack, mew=0, zorder=2, label='Pb+Pb')

    npart, nch = np.loadtxt('data/pPb.dat', usecols=(2, 3)).T
    plt.errorbar(npart.mean(), norm*nch.mean()/(npart.mean()/2), fmt='s',
                 capsize=0, zorder=1, mec=plt.cm.Blues(0.6), mfc='white',
                 mew=1, label=r'p+Pb')
    plt.errorbar(npart.mean(), 16.81/(npart.mean()/2),
                 yerr=0.71/(npart.mean()/2), fmt='s', capsize=0,
                 color=offblack, mew=0, zorder=2, label='p+Pb')

    plt.xlim(-20, 420)
    plt.xticks(np.arange(0,500,100))
    plt.xlabel(r'$N_\mathrm{part}$')
    plt.ylim(3, 11)
    plt.yticks(np.arange(4,12,2))
    plt.ylabel('$(dN_\mathrm{ch}/d\eta) / (N_\mathrm{part} / 2)$')

    handles, labels = plt.gca().get_legend_handles_labels()
    alice_handles = handles[1], handles[3]
    alice_labels = labels[1], labels[3]
    trento_handles = handles[0], handles[2]
    trento_labels = labels[0], labels[2]
    first_legend = plt.legend(alice_handles, alice_labels,
                              bbox_to_anchor=(0.74, 0.4), handlelength=0.8,
                              columnspacing=1.5, title='ALICE')
    first_legend.get_title().set_fontsize(textiny)
    plt.gca().add_artist(first_legend)
    second_legend = plt.legend(trento_handles, trento_labels,
                               bbox_to_anchor=(1, 0.4), handlelength=0.8,
                               columnspacing=1.5, title='TRENTO')
    second_legend.get_title().set_fontsize(textiny)
    plt.text(15, 10, '$\sqrt{s_{NN}}$ = 5.02 TeV')

    finish()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('plots', nargs='*')
    args = parser.parse_args()

    if args.plots:
        for i in args.plots:
            if i.endswith('.pdf'):
                i = i[:-4]
            if i in plot_functions:
                plot_functions[i]()
            else:
                print('unknown plot:', i)
    else:
        for f in plot_functions.values():
            f()


if __name__ == "__main__":
    main()
